        -:    0:Source:hashtables.c
        -:    0:Graph:hashtables.gcno
        -:    0:Data:hashtables.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:
        -:    4:#include "hashtables.h"
        -:    5:
        3:    6:int check_arg(int arg) {
        3:    7:    if (arg < 0) return 0;
        6:    8:    while (arg > 1) {
        5:    9:        if (arg % 2) return 0;
        4:   10:        arg /= 2;
        -:   11:    }
        1:   12:    return 1;
        3:   13:}
        -:   14:
        3:   15:HashTable *init_hashtable(int buffer_size, HASHTABLES_ERR *err) {
        -:   16:
        3:   17:    if (!check_arg(buffer_size)) {
        2:   18:        fprintf(stderr, "Invalig argument: buffer_size\n"
        -:   19:                        "Consider that buffer_size should be a pow of 2\n");
        2:   20:        if (err != NULL)
        2:   21:            *err = EINVARG;
        2:   22:        return NULL;
        -:   23:    }
        -:   24:
        1:   25:    HashTable *my_table = (HashTable *) malloc(sizeof(HashTable));
        -:   26:
        1:   27:    if (my_table == NULL) {
    #####:   28:        fprintf(stderr, "Not enough memory\n");
    #####:   29:        if (err != NULL)
    #####:   30:            *err = EMALLOC;
    #####:   31:        return NULL;
        -:   32:    }
        -:   33:
        1:   34:    my_table->size = 0;
        1:   35:    my_table->bufferSize = buffer_size;
        1:   36:    my_table->nodes = (Node **) malloc(buffer_size * sizeof(Node *));
        -:   37:
        1:   38:    if (my_table->nodes == NULL) {
    #####:   39:        fprintf(stderr, "Not enough memory\n");
    #####:   40:        if (err != NULL)
    #####:   41:            *err = EMALLOC;
    #####:   42:        return NULL;
        -:   43:    }
        -:   44:
        -:   45:
        5:   46:    for (int i = 0; i < buffer_size; ++i) {
        4:   47:        my_table->nodes[i] = NULL;
        4:   48:    }
        1:   49:    *err = ESUCCESS;
        1:   50:    return my_table;
        3:   51:}
        -:   52:
        2:   53:void remove_hashtable(HashTable *table, HASHTABLES_ERR *err) {
        2:   54:    if (table == NULL) {
        1:   55:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:   56:        if (err != NULL)
        1:   57:            *err = EINVARG;
        1:   58:        return;
        -:   59:    }
        -:   60:
      257:   61:    for (int i = 0; i < table->bufferSize; ++i) {
      256:   62:        if (table->nodes[i] != NULL) {
      101:   63:            free(table->nodes[i]);
      101:   64:        }
      256:   65:    }
        1:   66:    if (table->nodes != NULL) {
        1:   67:        free(table->nodes);
        1:   68:    }
        1:   69:    free(table);
        1:   70:    *err = ESUCCESS;
        2:   71:}
        -:   72:
      581:   73:int hash(int key, int buffer_size) {
      581:   74:    return abs(key) % buffer_size;
        -:   75:}
        -:   76:
      294:   77:int find_key(const int key, HashTable *table, HASHTABLES_ERR *err) {
        -:   78:
      294:   79:    if (table == NULL) {
        1:   80:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:   81:        if (err != NULL)
        1:   82:            *err = EINVARG;
        1:   83:        return 0;
        -:   84:    }
        -:   85:
      293:   86:    int hashed = hash(key, table->bufferSize);
      293:   87:    int i = 0;
     1001:   88:    while (table->nodes[hashed] != NULL && i < table->bufferSize) {
      713:   89:        if (!table->nodes[hashed]->deleted && table->nodes[hashed]->data == key) {
        5:   90:            *err = ESUCCESS;
        5:   91:            return 1;
        -:   92:        }
      708:   93:        i++;
      708:   94:        hashed += (i * i + i) / 2;
      708:   95:        hashed %= table->bufferSize;
        -:   96:    }
        -:   97:
      288:   98:    *err = ESUCCESS;
      288:   99:    return 0;
      294:  100:}
        -:  101:
        -:  102:
        7:  103:void rehash(HashTable *table, HASHTABLES_ERR *err) {
        -:  104:
        7:  105:    if (table == NULL) {
        1:  106:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:  107:        if (err != NULL)
        1:  108:            *err = EINVARG;
        1:  109:        return;
        -:  110:    }
        -:  111:
        6:  112:    Node **tmp = table->nodes;
        6:  113:    table->bufferSize *= 2;
        6:  114:    table->size = 0;
        6:  115:    table->nodes = (Node **) malloc(table->bufferSize * sizeof(Node *));
        -:  116:
        6:  117:    if (table->nodes == NULL) {
    #####:  118:        fprintf(stderr, "Not enough memory\n");
    #####:  119:        if (err != NULL)
    #####:  120:            *err = EMALLOC;
    #####:  121:        return;
        -:  122:    }
        -:  123:
      510:  124:    for (int i = 0; i < table->bufferSize; ++i) {
      504:  125:        table->nodes[i] = NULL;
      504:  126:    }
        -:  127:
      258:  128:    for (int i = 0; i < table->bufferSize / 2; ++i) {
      252:  129:        if (tmp[i] != NULL) {
      183:  130:            if (!tmp[i]->deleted)
      183:  131:                insert_key(tmp[i]->data, table, err);
      183:  132:            free(tmp[i]);
      183:  133:        }
      252:  134:    }
        6:  135:    free(tmp);
        6:  136:    *err = ESUCCESS;
        7:  137:}
        -:  138:
      289:  139:void insert_key(const int key, struct HashTable *table, HASHTABLES_ERR *err) {
        -:  140:
      289:  141:    if (table == NULL) {
        1:  142:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:  143:        if (err != NULL)
        1:  144:            *err = EINVARG;
        1:  145:        return;
        -:  146:    }
        -:  147:
      288:  148:    if (find_key(key, table, err)) {
        2:  149:        fprintf(stderr, "The key found in hashtable already\n");
        2:  150:        if (err != NULL)
        2:  151:            *err = EINSERT;
        2:  152:        return;
        -:  153:    }
        -:  154:
      286:  155:    if (3 * table->bufferSize <= 4 * (table->size + 1))
        6:  156:        rehash(table, err);
        -:  157:
      286:  158:    int hashed = hash(key, table->bufferSize);
      286:  159:    int i = 0;
      976:  160:    while (i < table->bufferSize) {
      976:  161:        if (table->nodes[hashed] == NULL) {
      284:  162:            table->nodes[hashed] = (Node *) malloc(sizeof(Node));
        -:  163:
      284:  164:            if (table->nodes == NULL) {
    #####:  165:                fprintf(stderr, "Not enough memory\n");
    #####:  166:                if (err != NULL)
    #####:  167:                    *err = EMALLOC;
    #####:  168:                return;
        -:  169:            }
        -:  170:
      284:  171:            table->nodes[hashed]->data = key;
      284:  172:            table->nodes[hashed]->deleted = 0;
      284:  173:            table->size++;
      284:  174:            *err = ESUCCESS;
      284:  175:            return;
      692:  176:        } else if (table->nodes[hashed]->deleted) {
        2:  177:            table->nodes[hashed]->data = key;
        2:  178:            table->nodes[hashed]->deleted = 0;
        2:  179:            table->size++;
        2:  180:            *err = ESUCCESS;
        2:  181:            return;
        -:  182:        }
      690:  183:        i++;
      690:  184:        hashed += (i * i + i) / 2;
      690:  185:        hashed %= table->bufferSize;
        -:  186:    }
      289:  187:}
        -:  188:
        4:  189:void remove_key(const int key, struct HashTable *table, HASHTABLES_ERR *err) {
        -:  190:
        4:  191:    if (table == NULL) {
        1:  192:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:  193:        if (err != NULL)
        1:  194:            *err = EINVARG;
        1:  195:        return;
        -:  196:    }
        -:  197:
        3:  198:    if (!find_key(key, table, err)) {
        1:  199:        fprintf(stderr, "The key was not found in hashtable\n");
        1:  200:        if (err != NULL)
        1:  201:            *err = EREMOVE;
        1:  202:        return;
        -:  203:    }
        -:  204:
        2:  205:    int hashed = hash(key, table->bufferSize);
        2:  206:    int i = 0;
        -:  207:
        4:  208:    while (i < table->bufferSize) {
        4:  209:        if (!table->nodes[hashed]->deleted && table->nodes[hashed]->data == key) {
        2:  210:            table->nodes[hashed]->deleted = 1;
        2:  211:            table->size--;
        2:  212:            *err = ESUCCESS;
        2:  213:            return;
        -:  214:        }
        2:  215:        i++;
        2:  216:        hashed += (i * i + i) / 2;
        2:  217:        hashed %= table->bufferSize;
        -:  218:    }
        4:  219:}
        -:  220:
        3:  221:void print_table(HashTable *table, HASHTABLES_ERR *err) {
        3:  222:    if (table == NULL) {
        1:  223:        fprintf(stderr, "Invalig argument: hashtable\n");
        1:  224:        if (err != NULL)
        1:  225:            *err = EINVARG;
        1:  226:        return;
        -:  227:    }
        -:  228:
        2:  229:    if (table->size == 0) {
        1:  230:        printf("No elements in hashtable\n");
        1:  231:        return;
        -:  232:    }
        -:  233:
      257:  234:    for (int i = 0; i < table->bufferSize; ++i) {
      256:  235:        if (table->nodes[i] != NULL && !table->nodes[i]->deleted) {
      101:  236:            printf("%d ", table->nodes[i]->data);
      101:  237:        }
      256:  238:    }
        1:  239:    printf("\n");
        1:  240:    *err = ESUCCESS;
        3:  241:}
